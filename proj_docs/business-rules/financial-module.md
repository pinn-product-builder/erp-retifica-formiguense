# üíµ M√≥dulo Financeiro - Regras de Neg√≥cio

## üéØ Vis√£o Geral

O M√≥dulo Financeiro gerencia todo o fluxo de caixa, contas a pagar e receber, controle banc√°rio, DRE e relat√≥rios financeiros, integrando-se automaticamente com outros m√≥dulos do sistema.

---

## üí∞ Contas a Receber

```mermaid
graph TD
    A[Or√ßamento Aprovado] --> B[Gerar Contas a Receber]
    B --> C{Forma de Pagamento}
    
    C -->|√Ä Vista| D[1x Parcela]
    C -->|Entrada + Saldo| E[2+ Parcelas]
    C -->|Parcelado| F[N Parcelas]
    
    D --> G[Status: Pendente]
    E --> G
    F --> G
    
    G --> H{Cliente Pagou?}
    H -->|Sim| I[Registrar Recebimento]
    H -->|N√£o| J{Venceu?}
    
    J -->|N√£o| G
    J -->|Sim| K[Status: Vencida]
    
    I --> L[Status: Paga]
    L --> M[Conciliar Banc√°rio]
    
    K --> N[Enviar Cobran√ßa]
    N --> H
    
    style L fill:#c8e6c9
    style K fill:#ffcdd2
```

### Gera√ß√£o Autom√°tica
Ao aprovar um or√ßamento, o sistema cria automaticamente as contas a receber:

```typescript
async function createReceivablesFromBudget(budget) {
  const {
    payment_terms,
    down_payment_percentage,
    installments_count,
    total
  } = budget;
  
  let accounts = [];
  
  if (payment_terms === 'cash') {
    // √Ä vista
    accounts.push({
      customer_id: budget.customer_id,
      order_id: budget.order_id,
      budget_id: budget.id,
      description: `Or√ßamento ${budget.number} - √Ä vista`,
      amount: total,
      due_date: addDays(new Date(), 1), // Amanh√£
      status: 'pending',
      installment: 1,
      total_installments: 1
    });
    
  } else if (payment_terms === 'down_payment_installments') {
    // Entrada + Parcelas
    const downPayment = total * (down_payment_percentage / 100);
    const remaining = total - downPayment;
    const installmentValue = remaining / installments_count;
    
    // Entrada
    accounts.push({
      description: `Or√ßamento ${budget.number} - Entrada`,
      amount: downPayment,
      due_date: addDays(new Date(), 1),
      status: 'pending',
      installment: 1,
      total_installments: installments_count + 1
    });
    
    // Parcelas
    for (let i = 1; i <= installments_count; i++) {
      accounts.push({
        description: `Or√ßamento ${budget.number} - Parcela ${i}/${installments_count}`,
        amount: i === installments_count 
          ? remaining - (installmentValue * (installments_count - 1)) // Ajuste √∫ltimo
          : installmentValue,
        due_date: addDays(new Date(), 30 * i), // A cada 30 dias
        status: 'pending',
        installment: i + 1,
        total_installments: installments_count + 1
      });
    }
    
  } else if (payment_terms === 'installments') {
    // Parcelado sem entrada
    const installmentValue = total / installments_count;
    
    for (let i = 1; i <= installments_count; i++) {
      accounts.push({
        description: `Or√ßamento ${budget.number} - Parcela ${i}/${installments_count}`,
        amount: i === installments_count
          ? total - (installmentValue * (installments_count - 1))
          : installmentValue,
        due_date: addDays(new Date(), 30 * i),
        status: 'pending',
        installment: i,
        total_installments: installments_count
      });
    }
  }
  
  // Inserir no banco
  for (const account of accounts) {
    await createAccountReceivable({
      ...budget.customer_info,
      ...account,
      org_id: budget.org_id,
      created_by: budget.approved_by
    });
  }
  
  return accounts;
}
```

### Status das Contas
- **Pendente** (`pending`): Aguardando pagamento
- **Paga** (`paid`): Recebimento confirmado
- **Vencida** (`overdue`): Passou da data de vencimento sem pagamento
- **Parcialmente Paga** (`partially_paid`): Recebeu apenas parte do valor
- **Cancelada** (`cancelled`): Or√ßamento foi cancelado

### Registro de Recebimento
```typescript
async function registerPayment(accountId, paymentData) {
  const account = await getAccountReceivable(accountId);
  
  // Registrar pagamento
  await createPaymentRecord({
    account_id: accountId,
    payment_date: paymentData.date,
    amount_paid: paymentData.amount,
    payment_method: paymentData.method, // cash, pix, card, bank_transfer
    bank_account_id: paymentData.bank_account,
    notes: paymentData.notes,
    receipt_url: paymentData.receipt_url
  });
  
  // Atualizar status
  const totalPaid = await getTotalPaid(accountId);
  
  if (totalPaid >= account.amount) {
    await updateAccount(accountId, { 
      status: 'paid',
      paid_at: new Date()
    });
  } else {
    await updateAccount(accountId, { 
      status: 'partially_paid',
      paid_amount: totalPaid
    });
  }
  
  // Atualizar fluxo de caixa
  await updateCashFlow({
    type: 'income',
    amount: paymentData.amount,
    date: paymentData.date,
    category: 'receita_servicos',
    reference_id: accountId
  });
  
  // Notificar (se configurado)
  if (account.total_paid === account.amount) {
    await notifyPaymentReceived(account);
  }
}
```

### Formas de Pagamento
- üíµ **Dinheiro** (`cash`)
- üî≤ **PIX** (`pix`)
- üí≥ **Cart√£o de Cr√©dito** (`credit_card`)
- üí≥ **Cart√£o de D√©bito** (`debit_card`)
- üè¶ **Transfer√™ncia Banc√°ria** (`bank_transfer`)
- üìÑ **Cheque** (`check`)
- üîÑ **Boleto** (`bank_slip`)

---

## üí∏ Contas a Pagar

```mermaid
graph TD
    A[Necessidade de Pagamento] --> B{Origem}
    
    B -->|Compra de Pe√ßas| C[Pedido de Compra]
    B -->|Despesa Operacional| D[Lan√ßamento Manual]
    B -->|Fornecedor| E[Nota Fiscal Recebida]
    
    C --> F[Criar Conta a Pagar]
    D --> F
    E --> F
    
    F --> G[Status: Pendente]
    G --> H{Vencimento Pr√≥ximo?}
    
    H -->|Sim - 3 dias| I[Alerta Amarelo]
    H -->|Hoje| J[Alerta Vermelho]
    H -->|N√£o| G
    
    G --> K[Efetuar Pagamento]
    K --> L[Registrar Comprovante]
    L --> M[Status: Paga]
    M --> N[Conciliar Banc√°rio]
    
    style M fill:#c8e6c9
    style I fill:#fff9c4
    style J fill:#ffcdd2
```

### Cria√ß√£o de Contas a Pagar

#### 1. Autom√°tica (via Compras)
Ao receber materiais de um pedido de compra:
```typescript
async function createPayableFromPurchaseOrder(poId, receivingData) {
  const po = await getPurchaseOrder(poId);
  
  await createAccountPayable({
    org_id: po.org_id,
    supplier_id: po.supplier_id,
    purchase_order_id: poId,
    description: `Pedido de Compra ${po.number}`,
    amount: po.total,
    due_date: calculateDueDate(po.payment_terms),
    category: 'materiais',
    status: 'pending',
    invoice_number: receivingData.invoice_number,
    invoice_url: receivingData.invoice_url
  });
}
```

#### 2. Manual (Despesas Operacionais)
```typescript
// Exemplos de despesas
const expenseCategories = [
  'energia_eletrica',
  'agua',
  'telefone_internet',
  'aluguel',
  'salarios',
  'encargos',
  'manutencao_equipamentos',
  'combustivel',
  'materiais_consumo',
  'servicos_terceiros',
  'impostos',
  'outros'
];
```

### Pagamento de Contas
```typescript
async function payAccountPayable(accountId, paymentData) {
  const account = await getAccountPayable(accountId);
  
  // Registrar pagamento
  await createPaymentRecord({
    account_payable_id: accountId,
    payment_date: paymentData.date,
    amount_paid: paymentData.amount,
    payment_method: paymentData.method,
    bank_account_id: paymentData.bank_account,
    voucher_url: paymentData.voucher_url,
    notes: paymentData.notes
  });
  
  // Atualizar status
  await updateAccountPayable(accountId, {
    status: 'paid',
    paid_at: paymentData.date,
    paid_by: paymentData.user_id
  });
  
  // Atualizar fluxo de caixa
  await updateCashFlow({
    type: 'expense',
    amount: paymentData.amount,
    date: paymentData.date,
    category: account.category,
    reference_id: accountId
  });
  
  // Se pagou antes do vencimento, calcular desconto obtido
  if (paymentData.date < account.due_date && paymentData.amount < account.amount) {
    const discount = account.amount - paymentData.amount;
    await recordDiscount(accountId, discount, 'early_payment');
  }
}
```

### Alertas de Vencimento
```typescript
// Job di√°rio que verifica vencimentos
async function checkUpcomingPayments() {
  const today = new Date();
  const threeDaysAhead = addDays(today, 3);
  
  // Contas vencendo em 3 dias
  const upcoming = await getAccountsPayable({
    status: 'pending',
    due_date: { between: [today, threeDaysAhead] }
  });
  
  for (const account of upcoming) {
    await createAlert({
      type: 'payment_due_soon',
      severity: 'warning',
      title: `Pagamento vence em ${differenceInDays(account.due_date, today)} dias`,
      description: `${account.description} - R$ ${account.amount}`,
      reference_id: account.id,
      assigned_to: 'financial_manager'
    });
  }
  
  // Contas vencidas
  const overdue = await getAccountsPayable({
    status: 'pending',
    due_date: { lessThan: today }
  });
  
  for (const account of overdue) {
    await updateAccountPayable(account.id, { status: 'overdue' });
    
    await createAlert({
      type: 'payment_overdue',
      severity: 'critical',
      title: `Pagamento vencido h√° ${differenceInDays(today, account.due_date)} dias`,
      description: `${account.description} - R$ ${account.amount}`,
      reference_id: account.id,
      assigned_to: 'financial_manager'
    });
  }
}
```

---

## üíπ Fluxo de Caixa

```mermaid
graph LR
    A[Movimenta√ß√µes Financeiras] --> B{Tipo}
    
    B --> C[Entradas]
    B --> D[Sa√≠das]
    
    C --> C1[Recebimentos de Clientes]
    C --> C2[Outras Receitas]
    
    D --> D1[Pagamentos a Fornecedores]
    D --> D2[Despesas Operacionais]
    D --> D3[Impostos]
    D --> D4[Sal√°rios]
    
    C1 --> E[Saldo Atual]
    C2 --> E
    D1 --> E
    D2 --> E
    D3 --> E
    D4 --> E
    
    E --> F[Proje√ß√£o Futura]
    F --> G[30 dias]
    F --> H[60 dias]
    F --> I[90 dias]
```

### Componentes do Fluxo de Caixa

#### 1. Saldo Inicial
```typescript
const saldoInicial = await getBankAccountsBalance();
```

#### 2. Entradas Realizadas (M√™s Atual)
```typescript
const entradasRealizadas = await sumPayments({
  type: 'income',
  date: { between: [startOfMonth, endOfMonth] },
  status: 'confirmed'
});
```

#### 3. Sa√≠das Realizadas (M√™s Atual)
```typescript
const saidasRealizadas = await sumPayments({
  type: 'expense',
  date: { between: [startOfMonth, endOfMonth] },
  status: 'confirmed'
});
```

#### 4. Saldo Atual
```typescript
const saldoAtual = saldoInicial + entradasRealizadas - saidasRealizadas;
```

#### 5. Proje√ß√µes Futuras
```typescript
// Pr√≥ximos 30 dias
const projecao30dias = {
  entradas_previstas: await sumAccountsReceivable({
    status: ['pending', 'partially_paid'],
    due_date: { between: [today, add30days] }
  }),
  saidas_previstas: await sumAccountsPayable({
    status: 'pending',
    due_date: { between: [today, add30days] }
  })
};

projecao30dias.saldo_projetado = saldoAtual 
  + projecao30dias.entradas_previstas 
  - projecao30dias.saidas_previstas;
```

### Gr√°fico de Fluxo de Caixa
- **Eixo X**: Tempo (dias/meses)
- **Eixo Y**: Valor (R$)
- **Linhas**:
  - üü¢ Entradas (verde)
  - üî¥ Sa√≠das (vermelho)
  - üîµ Saldo acumulado (azul)
  - üìä Proje√ß√£o (linha tracejada)

---

## üìä DRE (Demonstra√ß√£o do Resultado do Exerc√≠cio)

```mermaid
graph TD
    A[Receita Bruta] --> B[- Dedu√ß√µes]
    B --> C[= Receita L√≠quida]
    C --> D[- Custos]
    D --> E[= Lucro Bruto]
    E --> F[- Despesas Operacionais]
    F --> G[= EBITDA]
    G --> H[- Deprecia√ß√£o]
    H --> I[= EBIT]
    I --> J[- Impostos]
    J --> K[= Lucro L√≠quido]
    
    style A fill:#c8e6c9
    style K fill:#81c784
```

### Estrutura da DRE

```typescript
interface DRE {
  // RECEITAS
  receita_bruta: {
    receita_servicos: number;
    receita_pecas: number;
    outras_receitas: number;
    total: number;
  };
  
  // DEDU√á√ïES
  deducoes: {
    impostos_sobre_vendas: number; // ISS, PIS, COFINS
    devolucoes: number;
    descontos: number;
    total: number;
  };
  
  receita_liquida: number;
  
  // CUSTOS
  custos: {
    custo_pecas: number;
    custo_materiais: number;
    mao_de_obra_direta: number;
    total: number;
  };
  
  lucro_bruto: number;
  margem_bruta: number; // %
  
  // DESPESAS OPERACIONAIS
  despesas_operacionais: {
    despesas_administrativas: {
      salarios_admin: number;
      encargos: number;
      materiais_escritorio: number;
      total: number;
    };
    despesas_comerciais: {
      comissoes: number;
      marketing: number;
      total: number;
    };
    despesas_gerais: {
      aluguel: number;
      energia: number;
      agua: number;
      telefone: number;
      manutencao: number;
      outras: number;
      total: number;
    };
    total: number;
  };
  
  ebitda: number; // Lucro antes de juros, impostos, deprecia√ß√£o e amortiza√ß√£o
  
  // OUTRAS DESPESAS/RECEITAS
  depreciacao: number;
  despesas_financeiras: number;
  receitas_financeiras: number;
  
  ebit: number; // Lucro operacional
  
  // IMPOSTOS
  impostos: {
    irpj: number;
    csll: number;
    total: number;
  };
  
  lucro_liquido: number;
  margem_liquida: number; // %
}
```

### C√°lculo Autom√°tico
```typescript
async function calculateDRE(orgId, startDate, endDate) {
  // 1. RECEITAS
  const receitas = await calculateRevenue(orgId, startDate, endDate);
  
  // 2. DEDU√á√ïES
  const deducoes = await calculateDeductions(orgId, startDate, endDate);
  
  // 3. RECEITA L√çQUIDA
  const receitaLiquida = receitas.total - deducoes.total;
  
  // 4. CUSTOS
  const custos = await calculateCosts(orgId, startDate, endDate);
  
  // 5. LUCRO BRUTO
  const lucroBruto = receitaLiquida - custos.total;
  const margemBruta = (lucroBruto / receitas.total) * 100;
  
  // 6. DESPESAS OPERACIONAIS
  const despesas = await calculateOperationalExpenses(orgId, startDate, endDate);
  
  // 7. EBITDA
  const ebitda = lucroBruto - despesas.total;
  
  // 8. DEPRECIA√á√ÉO
  const depreciacao = await calculateDepreciation(orgId, startDate, endDate);
  
  // 9. EBIT
  const ebit = ebitda - depreciacao;
  
  // 10. IMPOSTOS (IRPJ, CSLL)
  const impostos = await calculateIncomeTaxes(orgId, ebit);
  
  // 11. LUCRO L√çQUIDO
  const lucroLiquido = ebit - impostos.total;
  const margemLiquida = (lucroLiquido / receitas.total) * 100;
  
  return {
    receita_bruta: receitas,
    deducoes,
    receita_liquida: receitaLiquida,
    custos,
    lucro_bruto: lucroBruto,
    margem_bruta: margemBruta,
    despesas_operacionais: despesas,
    ebitda,
    depreciacao,
    ebit,
    impostos,
    lucro_liquido: lucroLiquido,
    margem_liquida: margemLiquida
  };
}
```

### Visualiza√ß√£o
- **Tabela detalhada**: Todos os valores por categoria
- **Gr√°fico de barras**: Compara√ß√£o receita x despesas x lucro
- **Gr√°fico de linha**: Evolu√ß√£o mensal do lucro l√≠quido
- **Indicadores**: Margem bruta, margem l√≠quida, EBITDA

---

## üè¶ Concilia√ß√£o Banc√°ria

```mermaid
sequenceDiagram
    participant S as Sistema
    participant B as Banco
    participant U as Usu√°rio
    
    U->>S: Importar extrato banc√°rio
    S->>B: Baixar transa√ß√µes (API ou CSV)
    B-->>S: Lista de movimenta√ß√µes
    S->>S: Comparar com registros internos
    S->>U: Exibir diferen√ßas
    
    loop Para cada diferen√ßa
        U->>S: Classificar movimenta√ß√£o
        S->>S: Criar lan√ßamento correspondente
    end
    
    S->>S: Calcular saldo conciliado
    S-->>U: Concilia√ß√£o conclu√≠da
```

### Processo de Concilia√ß√£o
1. **Importar extrato**: CSV, OFX ou integra√ß√£o via API banc√°ria
2. **Matching autom√°tico**: Sistema tenta associar movimenta√ß√µes
3. **Revis√£o manual**: Usu√°rio confirma ou corrige associa√ß√µes
4. **Lan√ßamentos pendentes**: Criar registros para movimenta√ß√µes n√£o identificadas
5. **Confer√™ncia de saldo**: Saldo do sistema = Saldo banc√°rio

---

## üìÅ Plano de Contas

Estrutura hier√°rquica para categoriza√ß√£o de receitas e despesas:

```
1. RECEITAS
  1.1. Receitas Operacionais
    1.1.1. Receita de Servi√ßos
    1.1.2. Receita de Pe√ßas
    1.1.3. Receita de M√£o de Obra
  1.2. Outras Receitas
    1.2.1. Receitas Financeiras
    1.2.2. Receitas Eventuais

2. CUSTOS
  2.1. Custos Diretos
    2.1.1. Pe√ßas e Materiais
    2.1.2. M√£o de Obra Direta
  2.2. Custos Indiretos
    2.2.1. Materiais de Consumo
    2.2.2. Manuten√ß√£o de Equipamentos

3. DESPESAS
  3.1. Despesas Administrativas
    3.1.1. Sal√°rios Administrativos
    3.1.2. Encargos
    3.1.3. Material de Escrit√≥rio
  3.2. Despesas Comerciais
    3.2.1. Comiss√µes
    3.2.2. Marketing
  3.3. Despesas Gerais
    3.3.1. Aluguel
    3.3.2. Energia El√©trica
    3.3.3. √Ågua
    3.3.4. Telefone/Internet
    3.3.5. Combust√≠vel
  3.4. Despesas Financeiras
    3.4.1. Juros
    3.4.2. Tarifas Banc√°rias

4. IMPOSTOS
  4.1. Impostos Federais
  4.2. Impostos Estaduais
  4.3. Impostos Municipais
```

---

## üéØ Centro de Custos

Permite segregar custos/despesas por √°rea:

```typescript
const centroDeCustos = [
  { code: 'CC001', name: 'Produ√ß√£o/Usinagem' },
  { code: 'CC002', name: 'Montagem' },
  { code: 'CC003', name: 'Qualidade' },
  { code: 'CC004', name: 'Administrativo' },
  { code: 'CC005', name: 'Comercial' },
  { code: 'CC006', name: 'Log√≠stica' }
];
```

**Utiliza√ß√£o**: Ao lan√ßar uma despesa, atribuir a um centro de custo para an√°lise de rentabilidade por √°rea.

---

## üîí Permiss√µes

| A√ß√£o | Super Admin | Owner | Admin | Manager | Operator | Viewer |
|------|-------------|-------|-------|---------|----------|--------|
| Ver Contas a Receber | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ | ‚ùå | üìñ |
| Registrar Recebimento | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ | ‚ùå | ‚ùå |
| Ver Contas a Pagar | ‚úÖ | ‚úÖ | ‚úÖ | üìñ | ‚ùå | ‚ùå |
| Criar Conta a Pagar | ‚úÖ | ‚úÖ | ‚úÖ | ‚ùå | ‚ùå | ‚ùå |
| Pagar Conta | ‚úÖ | ‚úÖ | ‚úÖ | ‚ùå | ‚ùå | ‚ùå |
| Ver Fluxo de Caixa | ‚úÖ | ‚úÖ | ‚úÖ | üìñ | ‚ùå | üìñ |
| Ver DRE | ‚úÖ | ‚úÖ | ‚úÖ | üìñ | ‚ùå | ‚ùå |
| Concilia√ß√£o Banc√°ria | ‚úÖ | ‚úÖ | ‚úÖ | ‚ùå | ‚ùå | ‚ùå |

---

**√öltima Atualiza√ß√£o**: 2025-01-14  
**Vers√£o**: 1.0.0
